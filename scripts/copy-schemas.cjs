#!/usr/bin/env node
/* Copies schema JSON + integrity manifest from firmware docs into the package local schemas/ dir */
const fs = require('fs');
const path = require('path');

const srcDir = path.resolve(__dirname, '../docs/mqtt_schema');
// Place schemas inside src/schemas so that compiled code referencing ../schemas works after build (dist/cjs and dist/esm retain relative up-one-level path to schemas copied into package root at publish time).
const destDir = path.resolve(__dirname, '../src/schemas');

if (!fs.existsSync(srcDir)) {
  console.error('Source schema directory missing:', srcDir);
  process.exit(1);
}

fs.rmSync(destDir, { recursive: true, force: true });
fs.mkdirSync(destDir, { recursive: true });

const copyList = [
  'envelope.schema.json',
  'sensor_data.schema.json',
  'sensor_heartbeat.schema.json',
  'sensor_status.schema.json',
  'gateway_info.schema.json',
  'gateway_metrics.schema.json',
  'firmware_status.schema.json',
  'control_response.schema.json',
  'command.schema.json',
  'command_response.schema.json',
  'mesh_node_list.schema.json',
  'mesh_topology.schema.json',
  'mesh_alert.schema.json',
  'mesh_bridge.schema.json',
  'mqtt_v1_bundle.json',
  'validation_rules.md',
  'ota/ota-manifest.schema.json'
];

// Also copy types.ts into src/generated directory for isolated build (avoids external path at runtime)
const typesSource = path.join(srcDir, 'types.ts');
const typesDestDir = path.resolve(__dirname, '../src/generated');
if (fs.existsSync(typesSource)) {
  fs.mkdirSync(typesDestDir, { recursive: true });
  fs.copyFileSync(typesSource, path.join(typesDestDir, 'types.ts'));
}

for (const file of copyList) {
  const src = path.join(srcDir, file);
  const dest = path.join(destDir, file);
  if (fs.existsSync(src)) {
    // Ensure destination directory exists for subdirectories
    fs.mkdirSync(path.dirname(dest), { recursive: true });
    fs.copyFileSync(src, dest);
  } else {
    console.warn('[warn] missing expected schema asset:', file);
  }
}

// Attempt integrity file if present
const integrityCandidates = ['bundle_integrity.json', 'bundle_integrity.yaml'];
for (const cand of integrityCandidates) {
  const src = path.join(srcDir, cand);
  if (fs.existsSync(src)) {
    fs.copyFileSync(src, path.join(destDir, cand));
  }
}

console.log('Schema assets copied to', destDir);

// Copy to root schemas directory for package consumption  
const rootSchemasDir = path.resolve(__dirname, '../schemas');
fs.rmSync(rootSchemasDir, { recursive: true, force: true });
fs.mkdirSync(rootSchemasDir, { recursive: true });
for (const file of copyList.concat(integrityCandidates)) {
  const src = path.join(destDir, file);
  const dest = path.join(rootSchemasDir, file);
  if (fs.existsSync(src)) {
    // Ensure destination directory exists for subdirectories
    fs.mkdirSync(path.dirname(dest), { recursive: true });
    fs.copyFileSync(src, dest);
  }
}

// Also ensure dist schema copies if dist already exists (incremental builds)
const distCjs = path.resolve(__dirname, '../dist/cjs/schemas');
const distEsm = path.resolve(__dirname, '../dist/esm/schemas');
for (const d of [distCjs, distEsm]) {
  if (fs.existsSync(path.dirname(d))) {
    fs.rmSync(d, { recursive: true, force: true });
    fs.mkdirSync(d, { recursive: true });
    for (const file of copyList.concat(integrityCandidates)) {
      const src = path.join(destDir, file);
      const dest = path.join(d, file);
      if (fs.existsSync(src)) {
        // Ensure destination directory exists for subdirectories
        fs.mkdirSync(path.dirname(dest), { recursive: true });
        fs.copyFileSync(src, dest);
      }
    }
  }
}

// Generate embedded schema data TypeScript module for static imports (avoids runtime path issues)
const schemaDataPath = path.resolve(__dirname, '../src/schema_data.ts');
let schemaTs = '// AUTO-GENERATED by copy-schemas.cjs. Do not edit manually.\n';
schemaTs += '/* eslint-disable */\n';
function readJsonIfExists(name){
  const p = path.join(destDir, name);
  if (!fs.existsSync(p)) return null;
  try { return JSON.parse(fs.readFileSync(p, 'utf8')); } catch { return null; }
}
const jsonSchemaFiles = copyList.filter(f => f.endsWith('.json'));
for (const file of jsonSchemaFiles) {
  const varName = file.replace(/[-.\/]/g,'_').replace(/_schema_json$/,'_schema').replace(/\.json$/,'');
  const data = readJsonIfExists(file);
  if (data) {
    schemaTs += `export const ${varName} = ${JSON.stringify(data, null, 2)} as const;\n`;
  }
}
fs.writeFileSync(schemaDataPath, schemaTs);
console.log('Generated embedded schema module at', schemaDataPath);
